# 基本思路

- 优化更需要优化的Query
- 定位优化对象的性能瓶颈
- 明确优化目标
- 从Explain入手

## 优化更需要优化的Query

假设有一个 Query 每小时执行 10000 次，每次需要 20 个 IO。另外一个 Query 每小时执行 10 次，每次需要 20000 个 IO。

现在我们需要优化IO，为系统节省资源。

 我们先通过 IO 消耗方面来分析。可以看出，两个 Query 每小时所消耗的 IO 总数目是一样的，都是200000 IO/小时。假设我们优化第一个 Query，从20个IO降低到18个IO，也就是仅仅降低了 2 个IO，则我们节省了 2 * 10000 = 20000 （IO/小时）。而如果希望通过优化第二个 Query 达到相同的效果，我们必须要让每个 Query 减少 20000 / 10 = 2000 IO。优化第一个 Query 节省 2 个 IO远比第二个 Query 节省 2000 个 IO 来的容易。

优化CPU，原理和上面一样

## 定位优化对象的性能瓶颈

在拿到一条需要优化的 Query 之后，我们首先要判断出这个 Query 的瓶颈到底是 IO 还是CPU。到底是因为在数据访问消耗了太多的时间，还是在数据的运算（如分组排序等）方面花费了太多资源？

## 明确优化目标

一般来说，我们首先需要清楚的了解数据库目前的整体状态，同时也要清楚的知道数据库中与该 Query 相关的数据库对象的各种信息，而且还要了解该 Query 在整个应用系统中所实现的功能。了解了数据库整体状态，我们就能知道数据库所能承受的最大压力，也就清楚了我们能够接受的最悲观情况。把握了该 Query 相关数据库对象的信息，我们就应该知道实现该 Query 的消耗最理想情况下需要消耗多少资源，最糟糕又需要消耗多少资源。最后，通过该 Query 所实现的功能点在整个应用系统中的重要地位，我们可以大概的分析出该Query 可以占用的系统资源比例，而且我们也能够知道该 Query 的效率给客户带来的体验影响到底有多大。

## 从Explain入手
一个优秀的 SQL 调优人员（或者成为 SQL Performance Tuner），在优化任何一个 SQL 语句之前，都应该在自己头脑中已经先有一个预定的执行计划，然后通过不断的调整尝试，再借助 Explain 来验证调整的结果是否满足自己预定的执行计划。对于不符合预期的执行计划需要不断分析Query 的写法和数据库对象的信息，继续调整尝试，直至得到预期的结果。

# 基本原则

- 多使用profile
- 永远用小结果集驱动大结果集
- 尽可能在索引中完成排序
- 只取出自己需要的Columns
- 仅仅使用最有效的过滤条件
- 尽可能避免复杂的Join查询和子查询

## 永远用小结果集驱动大结果集
驱动结果集越大，所需要循环的此时就越多，那么被驱动表的访问次数自然也就越多，而每次访问被驱动表，即使需要的逻辑 IO 很少，循环次数多了，总量自然也不可能很小，而且每次循环都不能避免的需要消耗 CPU ，所以 CPU 运算量也会跟着增加。
所以，在优化 Join Query 的时候，最基本的原则就是“小结果集驱动大结果集”，通过这个原则来减少嵌套循环中的循环次数，达到减少 IO 总量以及 CPU 运算的次数。

## 只取出自己需要的Columns
对于任何 Query，返回的数据都是需要通过网络数据包传回给客户端，如果取出的 Column 越多，需要传输的数据量自然会越大，不论是从网络带宽方面考虑还是从网络传输的缓冲区来看，都是一个浪费。
如果是需要排序的 Query 来说，影响就更大了。MySQL 会根据Column的数量来选择排序算法，不同的排序算法性能是不一样的。

## 仅仅使用最有效的过滤条件
通过执行计划，调整索引条件，选择一条最佳的数据访问路径
有时候需要比较索引所占用的空间。占用空间更大，代表我们访问该索引所需要读取的数据量就会更多，因此我们要选择过滤条件最优的方案。

## 尽可能避免复杂的Join查询和子查询
如果使用的 MyISAM 存储引擎，并发一旦较高的时候，性能下降非常明显。所以，我们的 Query 语句所涉及到的表越多，所需要锁定的资源就越多。也就是说，越复杂的 Join 语句，所需要锁定的资源也就越多，所阻塞的其他线程也就越多。相反，如果我们将比较复杂的 Query 语句分拆成多个较为简单的 Query 语句分步执行，每次锁定的资源也就会少很多，所阻塞的其他线程也要少一些。
在高并发的系统中，牺牲单个 Query 的短暂响应时间而提高整体处理能力也是
非常值得的。优化本身就是一门平衡与取舍的艺术，只有懂得取舍，平衡整体，才能让系统更优。



# 索引

## 索引的优缺点

### 优点

- 提高数据的检索效率，降低数据库的IO成本
- 降低数据的排序成本

> 排序分组操作主要消耗的是我们的内存和 CPU 资源，如果我们能够在进行排序分组操作中利用好索
>
> 引，将会极大的降低 CPU 资源的消耗。

### 缺点

- 带来存储空间资源消耗的增长

## 创建索引的时机

- 较频繁的作为查询条件的字段应该创建索引
- 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
- 更新非常频繁的字段不适合创建索引
- 不会出现在 WHERE 子句中的字段不该创建索引

## 选择合适的索引

- 在选择组合索引的时候，当前 Query 中过滤性最好的字段在索引字段顺序中排列越靠前越好；
- 尽可能通过分析统计信息和调整 Query 的写法来达到选择合适索引。

## 索引的限制条件

- MyISAM 存储引擎索引键长度总和不能超过 1000 字节
- BLOB 和 TEXT 类型的列只能创建前缀索引
- 使用不等于（!= 或者 <>）的时候 MySQL 无法使用索引
- 过滤字段使用了函数运算后（如 abs(column)），MySQL 无法使用索引
- Join 语句中 Join 条件字段类型不一致的时候 MySQL 无法使用索引
- 使用 LIKE 操作的时候如果条件以通配符开始（ '%abc...'）MySQL 无法使用索引
- 使用非等值查询的时候 MySQL 无法使用 Hash 索引